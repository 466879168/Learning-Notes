# 组件化开发
如果我们讲一个页面中所有的处理全部放在一起 处理起来就会变得非常复杂，而且不利于后续的管理以及扩展

如果我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己的这部分的功能 那么之后整个页面的管理和维护就变得非常容易

组件化是Vuejs中的重要思想
它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用
认可的应用都会被抽象成一颗组件树

组件化思想的应用
有了组件化的思想 就可以利用组件化 更好的开发
将页面拆分成一个个的小的可复用的组件
我们的代码更加的方便组织和管理 扩展性也更好


组件的使用分为三个步骤
创建组件构造器
注册组件
使用组件 

调用Vue.xtend()方法创建组件构造器
调用Vue.component（）方法注册组件
在Vue实例的作用范围内使用组件

组件模板语法
script标签 类型必须是text/x-template
```
<script type='text/x-template' id="cpn>
<template id='cpn‘></template>
```
# 组件data为什么必须是函数?
首先如果不是一个函数Vue会直接报错
其次 原因在于Vue让每个组件对象都返回一个新的对象 如果是同一个对象 组件在多次使用后会相影响

# 组建通信
## 父传子
在组件中使用选项props来声明需要从父级接收到的数据

props的值有两种方式

1. 字符串数字，数组中的字符串就是传递过来的数据
2. 对象 对象可以设置传递时的类型，也可以设置默认值

required:true 设置true 表示这个属性必须要使用

~~~
props：{
//基础类型检查
propa:Number, //匹配数字
//多个可能的值
propB：[String,Number],
//必填的字符串
propC：{
type：String，
required：true
}，
带有默认值的数字
propD：{
type：Number，
default：100
}，
//带有默认值的对象
propE：{
type：Object,
//对象或者数组默认值必须从一个工厂函数获取
default：function(){
	return {message:'hello'}
},
//自定义验证函数
propF：{
validator:function(value){
//这个值必须匹配下列字符串中的一个
return ['success','warning','danger'].indexOf(value) !== -1
}
}
}

}
~~~
## 子传父

在子组件中，通过$emit()来触发事件。
	子组件末班中用@绑定事件 事件中用$emit发送出去一个事件
在父组件中，通过v-on来监听子组件事件。
父组件中监听这个事件 并且完成这个事件

## 父子组件的访问方式： $children
父组件访问子组件：使用$children或$refs
子组件访问父组件：使用$parent
$children是一个数组
用的话都是通过下标来使用


$refs 

直接访问根组件$root

# 插槽
组件的插槽也是为了让我们封装的组件更加具有扩展性。
让使用者可以决定组件内部的一些内容到底展示什么。

抽取共性 保留不同

最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。
一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。
是搜索框，还是文字，还是菜单。由调用者自己来决定。

插槽就是预备的空间

## 具名插槽
指定具体的名字 用slot 和 name相结合

~~~
<cpn>
<div slot='p'>

</div>
</cpn>
<slot name='p'></slot>

~~~
## 作用域插槽

父组件替换插槽的标签，但是内容由子组件来提供。


# 模块化

为什么要模块化？
js带来了很多问题 比如全局变量同名的问题
js文件顺序是强制性的 不能更改的





