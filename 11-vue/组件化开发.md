# 组件化开发
如果我们讲一个页面中所有的处理全部放在一起 处理起来就会变得非常复杂，而且不利于后续的管理以及扩展

如果我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己的这部分的功能 那么之后整个页面的管理和维护就变得非常容易

组件化是Vuejs中的重要思想
它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用
认可的应用都会被抽象成一颗组件树

组件化思想的应用
有了组件化的思想 就可以利用组件化 更好的开发
将页面拆分成一个个的小的可复用的组件
我们的代码更加的方便组织和管理 扩展性也更好


组件的使用分为三个步骤
创建组件构造器
注册组件
使用组件 

调用Vue.xtend()方法创建组件构造器
调用Vue.component（）方法注册组件
在Vue实例的作用范围内使用组件

组件模板语法
script标签 类型必须是text/x-template
```
<script type='text/x-template' id="cpn>
<template id='cpn‘></template>
```
# 组件data为什么必须是函数?
首先如果不是一个函数Vue会直接报错
其次 原因在于Vue让每个组件对象都返回一个新的对象 如果是同一个对象 组件在多次使用后会相影响

# 组建通信
## 父传子
**第一步：在父组件的模板中在子组件标签属性用bind定义要使用的数据
第二步：在子组件中用props接收数据**
在组件中使用选项props来声明需要从父级接收到的数据

## 爷传孙
第一种：一级一级往下传递
第二种： 父元素如果没有使用爷元素中的属性 爷元素中的属性都挂载在this.$attrs里面

inheritAttrs：false 没有用到的数据不会在DOM树上显示

props的值有两种方式

1. 字符串数字，数组中的字符串就是传递过来的数据
2. 对象 对象可以设置传递时的类型，也可以设置默认值

required:true 设置true 表示这个属性必须要使用

~~~
props：{
//基础类型检查
propa:Number, //匹配数字
//多个可能的值
propB：[String,Number],
//必填的字符串
propC：{
type：String，
required：true
}，
带有默认值的数字
propD：{
type：Number，
default：100
}，
//带有默认值的对象
propE：{
type：Object,
//对象或者数组默认值必须从一个工厂函数获取
default：function(){
	return {message:'hello'}
},
//自定义验证函数
propF：{
validator:function(value){
//这个值必须匹配下列字符串中的一个
return ['success','warning','danger'].indexOf(value) !== -1
}
}
}

}
~~~
## 子传父

$listeners
在子组件中，通过$emit()来触发事件。
	子组件末班中用@绑定事件 事件中用$emit发送出去一个事件
在父组件中，通过v-on来监听子组件事件。
父组件中监听这个事件 并且完成这个事件

## 父子组件的访问方式： $children
父组件访问子组件：使用$children或$refs
子组件访问父组件：使用$parent
$children是一个数组
用的话都是通过下标来使用


$refs 

直接访问根组件$root

# 插槽
组件的插槽也是为了让我们封装的组件更加具有扩展性。
让使用者可以决定组件内部的一些内容到底展示什么。

抽取共性 保留不同

最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。
一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。
是搜索框，还是文字，还是菜单。由调用者自己来决定。

插槽就是预备的空间

## 具名插槽
指定具体的名字 用slot 和 name相结合

~~~
<cpn>
<div slot='p'>

</div>
</cpn>
<slot name='p'></slot>

~~~
## 作用域插槽

父组件替换插槽的标签，但是内容由子组件来提供。


# 模块化

为什么要模块化？
js带来了很多问题 比如全局变量同名的问题
js文件顺序是强制性的 不能更改的

# native
想在父组件中绑定原生事件给组件 需要添加native 直接绑定到组件的根元素身上


# 获取dom
要获取dom的话再元素身上添加ref='app'的属性
在Vue中通过this.$refs.app获取元素
当两个元素的ref值相同的时候 获取的是最后一个 后面的覆盖前面的
ref只能识别一个 不能给多个元素设置相同的ref
遇到循环 获取的是多个元素 是数组的形式

遇到组件 获取的是一个组件实例

# 自定义指令
使用的时候不要加v- 因为Vue会认识它
使用directives：{}声明这个指令
~~~
v-limit="msg"
Vue.directive('limit',function(el,bindings,vnode){
//el: 指令作用在哪个元素上面
//bindings: 指令相关的属性
//vnode: 虚拟	DOM JS对象 代表了这个元素
})
~~~